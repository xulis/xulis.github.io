<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>DevOps &amp; 0x001 on (b (s x g))</title>
    <link>/blog/</link>
    <description>Recent content in DevOps &amp; 0x001 on (b (s x g))</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Fri, 19 Jul 2019 00:00:00 +0800</lastBuildDate><atom:link href="/blog/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>JavaScript用到的一些编程范式</title>
      <link>/blog/2019-07-19-js/</link>
      <pubDate>Fri, 19 Jul 2019 00:00:00 +0800</pubDate>
      
      <guid>/blog/2019-07-19-js/</guid>
      <description>&amp;ldquo;这是之前发在自己公众号的一篇文章， 直接搬过来&amp;rdquo;
  在运维世界里，有时候你可以做一些没有也可以， 但是有就更好的各种xx管理平台。最近， 我也想弄一个你们DevOps所说的“运维管理平台。 其实也没什么运不运维，本质上来说就是Web开发。
 所以， 我又一股脑地投向了前端娱乐圈。
 我不是一个实在的人，我每时每刻都在追求那些不切实际的东西，如若要搞前端，自然也不例外，当别人的眼神流露出对我还在玩上个月的框架的鄙视时， 我就恨不得从一开始就没有玩过前端。基于此，我大部分时间都在刷行业动态，GraphQL、LiveView、React牛逼还是Vue牛逼，Angular更新到什么版本了？TypeScript对比ELM有什么优势&amp;hellip;刷得精疲力尽之后，开始工作。
 经过两天这里看一下那里看一下，我学习了一些JavaScript的入门知识，写下此文以作记录，考虑到要除去中间开小差的时间，取名《JavaScript一日游》，主要记录JavaScript中的惯用编程范式。
 相对于别的编程语言来说，JavaScript简直就是嬉皮士，你想规规矩矩面向对象的时候它让你必须函数式一下，你想纯粹函数式的时候在某一时刻发现数据状态必须改一改，当然你很牛逼，这都不是事儿。然而由于NodeJS运行时是基于异步IO和事件循环模型， 你就死在了程序和事件一起写这件事上面。所以，用JavaScript来学习JavaScript的编程范式，并不是最好的方法，因为在学习之前，要踩过去的坑太多，所以接下来我用Racket来解释JavaScript编程范式，用最简单的方式来讲解(毕竟复杂的我也不会 -。- )。
0x00: 回调 (callback)  选择NodeJS就是选择异步编程，就如前文所说，在很多时候你是程序和事件(event)一起写，程序就一步一步跑，事件会被丢到事件循环列表(poll queue)中，程序安安稳稳跑完，事件就不断被遍历执行，因为其丢到了队列里，所以不会阻塞程序的执行，所以有时候你的程序看起来执行顺序有点迷，比如有两个函数AB，按顺序调用AB，执行时却发现B先执行，A跟在了B屁股后面，这种事情你别问为什么，一问就发生：
#lang racket (define 🐢 (displayln &amp;#34;🐢🐢🐢...&amp;#34;)) (define 🐇 (displayln &amp;#34;🐇🐇🐇...&amp;#34;)) 🐢 🐇  我们定义了乌龟和兔子两个函数，先调用乌龟函数，再调用兔子函数，正常来说我们会看到这样的输出：
🐢🐢🐢... 🐇🐇🐇...  但是在NodeJS里面，你很可能会看到这样的输出：
🐇🐇🐇... 🐢🐢🐢...  因为乌龟跑得慢，NodeJS是异步设计，有一些慢的执行(异步操作)就不等了，直接把它丢poll queue里，之后等待Event Loop轮到它的时候再执行，所以兔子就不等乌龟，自己先跑完了，乌龟在队列里排队。
 现在知道为什么NodeJS那么快了吧，在日常应用中，比如网路、IO这些比较慢的操作，NodeJS直接异步了丫的，让后面的程序先跑。不过快是快，就是程序行为有时候会很迷～
 那么有什么方法可以解决这种情况呢？毕竟有时候乌龟必须要在兔子前面，比如乌龟是兔子的女朋友，兔子跑赢乌龟就是找死，或者有一个操作强依赖前面那个异步的操作。
 这时候就用到回调了。
 回调呢，专业术语就是：回来之后再调用它丫的，呸呸呸，是“is any executable code that is passed as an argument to other code that is expected to call back (execute) the argument at a given time.</description>
    </item>
    
    <item>
      <title>线性递归、线性迭代和树形递归</title>
      <link>/blog/2016-07-14-golang-try/</link>
      <pubDate>Thu, 14 Jul 2016 00:00:00 +0800</pubDate>
      
      <guid>/blog/2016-07-14-golang-try/</guid>
      <description>刚刚看到线性递归、线性迭代和树形递归这几个概念，一时兴起，便模仿起来，也算是入门练手吧，恰巧最近在看Golang这门很简陋(哈哈~~)的语言。
//线性递归方法求阶乘  package main import &amp;#34;fmt&amp;#34; func main() { fmt.Println(factorial(6)) } func factorial(i int) (n int) { if i == 1 { return 1 } else { return i * factorial(i-1) } } //树形递归方法求某个斐波那契数  package main import &amp;#34;fmt&amp;#34; func main() { fmt.Println(fib(8)) } func fib(i int) int { switch i { case 0: return 0 case 1: return 1 default: return fib(i-1) + fib(i-2) } } //线性迭代方法求某个斐波那契数  package main import &amp;#34;fmt&amp;#34; func main() { fmt.</description>
    </item>
    
    <item>
      <title>2300年前的欧几里得算法</title>
      <link>/blog/2018-06-07-algorithms-gcd/</link>
      <pubDate>Mon, 01 Feb 2016 00:00:00 +0800</pubDate>
      
      <guid>/blog/2018-06-07-algorithms-gcd/</guid>
      <description>2300年前的欧几里得算法，做的是这样一件事情：找出两个数的最大公约数。
自然语言描述： 计算两个非负整数p和q的最大公约数：若q是0，则最大公约数为p。否则，将p除以q得到余数r,p和q的最大公约数即为q和r的最大公约数。 PS: 欧几里得大概是很无聊的，那么奇怪的规律也能找到。
实现:
defmodule Alt do def gcd(p, 0), do: p def gcd(p, q), do: gcd(q, rem(p, q)) end IO.puts Alt.gcd(10,4) #-&amp;gt; 2  IO.puts Alt.gcd(10,0) #-&amp;gt; 10 </description>
    </item>
    
    <item>
      <title>正则序和应用序</title>
      <link>/blog/2016-02-01-ao-and-no/</link>
      <pubDate>Mon, 01 Feb 2016 00:00:00 +0800</pubDate>
      
      <guid>/blog/2016-02-01-ao-and-no/</guid>
      <description>要点: 正则序：先展开过程，再求值。 应用序：先求值，再代入过程。
对于以下代码:
(define (p) (p)) (define (test x y) (if (= x 0) 0 y)) (test 0 (p)) 如果解释器采用的是应用序，则程序会不断地执行，因为需要求值p函数，然而p函数返回自己，因此进入死循环。
(test 0 (p)) (test 0 (p)) (test 0 (p)) ...  而对于采用正则序的解释器，程序则能成功输出0，因为，解释器先展开过程，再求值(如果表达式有用到，而这里因为x=0，并没有用到p函数)，过程是这样的:
(test 0 (p)) (if (= 0 0) 0 (p)) (if #t 0 (p)) 0 </description>
    </item>
    
  </channel>
</rss>
